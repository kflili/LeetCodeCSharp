# LeetCode solution in C#


### Part 1 Solved problem List
---

**_[1. LeetCode Courses](https://leetcode.com/courses/)_**

<<<<<<< HEAD
=======
ID|Tags|Difficulty|Solution
--|----|----------|--------
26|Array, Two Pointers|Easy|[Remove Duplicates from Sorted Array](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_26_RemoveDuplicatesfromSortedArray.cs)
167|Array, Two Pointers, Binary Search|Easy|[Two Sum II - Input array is sorted](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_167_TwoSumII.cs)
242|String, HashTable|Easy|[Valid Anagram](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_242_ValidAnagram.cs)
3|String, HashTable, Two Pointers|Medium|[Longest Substring Without Repeating Characters](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_3_LongestSubstringWithoutRepeatingCharacters.cs)
28|String, Two Pointers|Easy|[Implement strStr()](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_28_ImplementstrStr.cs)
8|String, Math|Medium|[String to Integer (atoi)](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_8_StringtoInteger.cs)
237|LinkedList|Easy|[Delete Node in a Linked List](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_237_DeleteNodeinaLinkedList.cs)
206|LinkedList|Easy|[Reverse Linked List](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_206_ReverseLinkedList.cs)
141|LinkedList, Two Pointers|Easy|[Linked List Cycle](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_141_LinkedListCycle.cs)
21|LinkedList, Merge Sort|Easy|[Merge Two Sorted Lists](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_21_MergeTwoSortedLists.cs)
24|LinkedList|Medium|[Swap Nodes in Pairs](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_24_SwapNodesinPairs.cs)
104|Tree, Depth-first Search|Easy|[Maximum Depth of Binary Tre](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_104_MaximumDepthofBinaryTree.cs)
100|Tree, Depth-first Search|Easy|[MSame Tree](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_100_SameTree.cs)
112|Tree, Depth-first Search|Easy|[Path Sum](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_112_PathSum.cs)
257|Tree, Depth-first Search|Easy|[Binary Tree Paths](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_257_BinaryTreePaths.cs)
98|Tree, Depth-first Search|Easy|[Validate Binary Search Tree](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_98_ValidateBinarySearchTree.cs)
225|Stack, Queue|Easy|[Implement Stack using Queues](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_225_ImplementStackusingQueues.cs)
>>>>>>> parent of b4067c3... add chapter title in list


 
<br>
<br>


### Part 2   Problem descriptions
---

**_[1. LeetCode Courses](https://leetcode.com/courses/)_**

**Algorithms Basics**  
Selected interview questions aimed for beginners who do not know algorithms or need a refresher. Learn by doing.
#### CHAPTER 1. ARRAY / STRING
**_26. Remove Duplicates from Sorted Array_**

**Description:**
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array nums = [1,1,2],  
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_26_RemoveDuplicatesfromSortedArray.cs)

**_167. Two Sum II - Input array is sorted_**

**Description:**
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution and you may not use the same element twice.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_167_TwoSumII.cs)

**_242. Valid Anagram_**

**Description:**
Given two strings s and t, write a function to determine if t is an anagram of s.

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

Note:
You may assume the string contains only lowercase alphabets.

Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_242_ValidAnagram.cs)

**_3. Longest Substring Without Repeating Characters_**

**Description:**
Given a string, find the length of the longest substring without repeating characters.

Examples:

Given "abcabcbb", the answer is "abc", which the length is 3.

Given "bbbbb", the answer is "b", with the length of 1.

Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_3_LongestSubstringWithoutRepeatingCharacters.cs)

**_28. Implement strStr()_**

**Description:**
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_28_ImplementstrStr.cs)

**_8. String to Integer (atoi)_**

**Description:**
Implement atoi to convert a string to an integer.

Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_8_StringtoInteger.cs)


#### CHAPTER 2. LINKED LIST

**_237. Delete Node in a Linked List_**

**Description:**
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_237_DeleteNodeinaLinkedList.cs)

**_206. Reverse Linked List_**

**Description:**
Reverse a singly linked list.

Hint:
A linked list can be reversed either iteratively or recursively. Could you implement both?

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_206_ReverseLinkedList.cs)

**_141. Linked List Cycle_**

**Description:**
Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_141_LinkedListCycle.cs)

**_21. Merge Two Sorted Lists_**

**Description:**
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_21_MergeTwoSortedLists.cs)

**_24. Swap Nodes in Pairs_**

**Description:**
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_24_SwapNodesinPairs.cs)

#### CHAPTER 3. BINARY TREE

**_104. Maximum Depth of Binary Tree_**

**Description:**
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_104_MaximumDepthofBinaryTree.cs)

**_100. Same Tree_**

**Description:**
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_100_SameTree.cs)

**_112. Path Sum_**

**Description:**
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

For example:
Given the below binary tree and sum = 22,
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_112_PathSum.cs)

**_257. Binary Tree Paths_**

**Description:**
Given a binary tree, return all root-to-leaf paths.

For example, given the following binary tree
```
  1
 / \
2   3
 \
  5
```

All root-to-leaf paths are:

["1->2->5", "1->3"]

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_257_BinaryTreePaths.cs)

**_98. Validate Binary Search Tree_**

**Description:**
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
```
    2
   / \
  1   3
```
Binary tree [2,1,3], return true.
Example 2:
```
    1
   / \
  2   3
```
Binary tree [1,2,3], return false.

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_98_ValidateBinarySearchTree.cs)

#### CHAPTER 4. STACK AND QUEUE

**_225. Implement Stack using Queues_**

**Description:**
Implement the following operations of a stack using queues.

push(x) -- Push element x onto stack.  
pop() -- Removes the element on top of the stack.  
top() -- Get the top element.  
empty() -- Return whether the stack is empty.  

Notes:
You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.

Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
  
You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).

[My Solution Code](https://github.com/kflili/LeetCodeCSharp/blob/master/LeetCodeCSharp/_225_ImplementStackusingQueues.cs)

